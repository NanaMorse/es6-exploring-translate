# 7.Symbols

## 7.1 概述

`Symbols` 是 `ECMAScript 6` 中出现的一种新的基本类型。

### 7.1.1 用例 1: 具有唯一性的属性键名

`Symbols` 主要用来作为一个具有唯一性的属性键名来使用，一个 `symbol` 永远不会与任意其他的属性键名（不论是 `symbol` 还是 `string`）发生命名冲突。举个例子，你可以通过使用存储在 `Symbol.iterator` 中的 `symbol` 作为一个对象中方法的键名，来使这个对象变成可遍历对象［注1］。

``` javascript
	const iterableObject = {
		[Symbol.iterator]() { // (A)
			const data = ['hello', 'world'];
			let index = 0;
			return {
				next() {
					if (index < data.length) {
						return { value : data[index++] }
					} else {
						return { done : true }
					}
				}
			}
		}
	}
	
	for (const x of iterableObject) {
		console.log(x);
	}
	
	// Output:
	// hello
	// world
``` 

在行A中，一个 `symbol` 被用作了一个方法的键名，这个唯一的标记使该方法所属的对象可被 `for-of` 循环遍历。

### 7.1.2 用例 2：代表概念性常量

在 `ECMAScript 5` 里，你可能用过字符串来代表一些概念，例如颜色。在 `ECMAScript 6`中，你可以使用 `symbols` 来确保它们总是独立唯一的：

``` javascript
	const COLOR_RED = Symbol('Red');
	const COLOR_GREEN = Symbol('Green');
	const COLOR_BLUE = Symbol('Blue');
	
	function getComplement(color) {
		switch (color) {
			case COLOR_RED : 
				return COLOR_GREEN;
			case COLOR_GREEN :
				return COLOR_BLUE;
			case COLOR_BLUE : 
				return COLOR_RED;
			default : 
				throw new Exception('Unknown color: ' + color);
		}
	}

```

### 7.1.3 陷阱：不要把 `symbols` 当作 `strings` 对待
把 `symbols` 隐式转换为 `strings` 会抛出异常：

``` javascript
	const sym = Symbol('desc');
	
	const str1 = '' + sym; // TypeError
	const str2 = `${sym}`; // TypeError
```

唯一的解决方案是对其显式转换：

``` javascript
	const str2 = String(sym); // 'Symbol(desc)'
	const str3 = sym.toString(); // 'Symbol(desc)'
```

禁止隐式转换可以避免一些错误，但这也同时令使用 `symbols` 变得更加复杂。

### 7.1.4 哪些与属性键名相关的操作可以注意到 `symbols` ？

下列操作可以注意到 `symbols` 类型的键名：

* `Reflect.ownKeys()`
* 通过 `[]` 获取属性
* `Object.assign()`

下列操作会忽略 `symbols` 类型的键名：

* `Object.keys()`
* `Object.getOwnPropertyNames()`
* `for-in` 循环

## 7.2 一个新的基本类型
`ECMAScript 6` 引入了一种新的基本类型： `symbols` 。它们是用来作为唯一性ID使用的标记。通过使用工厂函数 `Symbol()` 来创建 `symbols`。

``` javascript 
	const symbol1 = Symbol();
```

`Symbol()`函数可以接受一个可选的 `string` 类型参数，用来给新创建的 `symbol` 添加一个说明。当 `symbol` 被转换为 `string` 的时候这个说明也会被用到。

``` javascript
	const symbol2 = Symbol('morse');
	String(symbol2); // 'Symbol(morse)'
```

通过 `Symbol()` 获得的所有 `symbol` 都是独一无二的，每一个 `symbol` 都有它自己的身份信息：

``` javascript
	Symbol() === Symbol(); // false
```

如果你用 `typeof` 运算符去操作一个 `symbol` 的话，运算结果会返回一个为 `symbol` 特制的结果，这证明 `symbols` 确实是一种基本类型。

``` javascript
	typeof Symbol(); // 'symbol'
```

### 7.2.1 作为属性键名的 `Symbols`
`Symbols` 可以用来作为属性键名使用：

``` javascript
	const MY_KEY = Symbol();
	const obj = {};
	
	obj[MY_KEY] = 123;
	console.log(obj[MY_KEY]); // 123
```

类 `Classes` 与`对象字面量`有一种名为`computed property keys`的特性：你可以使用一个返回值的表达式来定义键名，具体做法就是把它包含在方括号中。在下面的对象字面量中，我们使用一个表达式运算结果键名来确保 `MY_KEY` 的值成为某个属性的键名。

``` javascript
	const MY_KEY = Symbol();
	const obj = {
		[MY_KEY] : 123
	};
```

方法定义也可以使用表达式运算结果键名：

``` javascript
	const FOO = Symbol();
	const obj = {
		[FOO]() {
			return 'bar';
		}
	};
	
	console.log(obj[FOO]());  // bar
```

### 7.2.2 枚举自身的属性键名
由于已经出现了一种可以用来作为对象属性键名的新类型变量，`ECMAScript 6` 中会使用下列术语：

* 属性键名类型是 `strings` 或者 `symbols` 两者其一。
* `String` 类型的属性键名被称为属性名称。
* `Symbol` 类型的属性键名被称为属性symbol。

让我们来检查一下那些用来枚举属性键名的API的工作情况，首先来创建一个对象。

``` javascript
	const obj = {
		[Symbol('my_key')] : 1,
		enum : 2,
		nonEnum : 3
	};
	Object.defineProperty(obj, 'nonEnum', {
		enumerable : false
	});
```

`Object.getOwnPropertyNames()` 会忽略 `symbol` 类型的属性键名：

``` javascript
	Object.getOwnPropertyNames(obj);
	// ['enum', 'nonEnum']
```

`Object.getOwnPropertySymbols()` 会忽略 `string` 类型的属性键名：

``` javascript
	Object.getOwnPropertySymbols(obj)	
	// [Symbol(my_key)]
```

`Reflect.ownKeys()` 会考虑到所有类型的键名：

``` javascript
	Reflect.ownKeys(obj)
	// [Symbol(my_key), 'enum', 'nonEnum']
```

`Object.keys()` 仅仅注意那些可被枚举的 `string` 类型键名：

``` javascript
	Object.keys(obj)
	// ['enum']
```
`Object.keys`的命名已经与新的技术标准起了冲突，因为它仅仅列举出那些 `string` 类型的键名。
`Object.names` 或者 `Object.getEnumerableOwnPropertyNames` 会是现在更好的选择。

## 7.3 用 `symbols` 来指代概念
在 `ECMAScript 5` 中，开发者经常使用字符串来指代一些概念（想一想可枚举常量），例如：

``` javascript
	var COLOR_RED    = 'Red';
	var COLOR_ORANGE = 'Orange';
	var COLOR_YELLOW = 'Yellow';
	var COLOR_GREEN  = 'Green';
	var COLOR_BLUE   = 'Blue';
	var COLOR_VIOLET = 'Violet';
```
然而，字符串并不像我们期待的那样是具有唯一性的。要知道原因，让我们来看看下面的这个函数：

``` javascript
	function getComplement(color) {
    	switch (color) {
        	case COLOR_RED:
            	return COLOR_GREEN;
        	case COLOR_ORANGE:
            	return COLOR_BLUE;
        	case COLOR_YELLOW:
            	return COLOR_VIOLET;
        	case COLOR_GREEN:
            	return COLOR_RED;
        	case COLOR_BLUE:
            	return COLOR_ORANGE;
        	case COLOR_VIOLET:
            	return COLOR_YELLOW;
        	default:
            	throw new Exception('Unknown color: '+color);
    	}
	}
```

可以看到，你可以用任意的方式来使用断言表达式，例如 `switch` 语句，例如：

``` javascript
	function isThree(x) {
    	switch (x) {
        	case 1 + 1 + 1:
            	return true;
        	default:
            return false;
    	}
	}
```
我们可以利用 `switch` 语句提供的灵活性来让 `case` 分支指向我们的常量（`COLOR_RED`等等），而不是写一些“硬代码”（`RED`等等）。

但是即使我们这样做，代码依然有可能出现问题。例如，某些人可能会为`情绪`定义一个常量：

``` javascript
	const MOOD_BLUE = 'BLUE';
```

现在 `BLUE` 的值再也不是独一无二的了，它会因为 `MOOD_BLUE` 的存在而出现错误。如果你把 `MOOD_BLUE` 作为 `getComplement()` 的参数传入，函数将会返回 `'ORANGE'` ，但正确的行为应该是抛出一个错误。

让我们用 `symbols` 来修复这个例子吧。我们可以使用 `ES6` 的新特性 `const` ，它允许我们定义真实的常量。（你无法改变一个常量的值，但值本身可能是可变的）。

``` javascript
	const COLOR_RED    = Symbol('Red');
	const COLOR_ORANGE = Symbol('Orange');
	const COLOR_YELLOW = Symbol('Yellow');
	const COLOR_GREEN  = Symbol('Green');
	const COLOR_BLUE   = Symbol('Blue');
	const COLOR_VIOLET = Symbol('Violet');
```

每一个由 `Symbol` 返回的值都是独一无二的，再也没有任何别的值会令 `BLUE` 发生错误了。有意思的是，即使我们用 `Symbol` 替换了 `String`，函数 `getComplement()` 的代码也不需要发生任何改变，这展示了这两者是多么的相似。

## 7.4 作为属性键名的 `Symbols`

创建一个自身键名永远不会与其它的键名发生冲突的属性在下面两种情景中非常有用：

* 在继承层级中创建非公有属性
* 保证新创建的属性不会与继承的属性发生冲突

### 7.4.1 作为非公有属性键名的 `Symbols`

在javascript中到处都有继承，在继承中，存在两种类型的属性

* 在客户端代码中可以看到的公共属性。
* 被继承块内部存在的私有属性，它们一起构成了继承层级。

易用起见，公共属性总是使用字符串键名。但如果私有属性也用字符串键名，意外的命名冲突就很是一个问题。因此，`symbols` 在这里就是一个很好的选择。例如，在下面的代码中， `symbols` 被用在了私有属性 `_counter` 和 `_action` 上。

``` javascript
	const _counter = Symbol('counter');
	const _action = Symbol('action');
	class Countdown {
    	constructor(counter, action) {
        	this[_counter] = counter;
        	this[_action] = action;
    	}
    	dec() {
        	let counter = this[_counter];
        	if (counter < 1) return;
        	counter--;
        	this[_counter] = counter;
        	if (counter === 0) {
            	this[_action]();
        	}
    	}
	}

```

注意， `symbols` 仅仅保护你避免命名冲突，它并不能避免非法存取，因为你可以通过 `Reflect.ownKeys()` 方法枚举所有属性键名，包括 `symbols` 类型的键名。如果你想要避免非法存取，请参见“类的私有数据”。

### 7.4.2 作为元级属性键名的 `Symbols`

`Symbols` 所具有的唯一性特征，使得它非常适合被用来作为与普通属性键名处于不同层级的公共属性的键名，因为元级键名与普通键名之间绝对不能发生冲突。一个关于元级属性的例子就是，对象的方法可以被重写。使用 `symbol` 键名可以防止个人方法无意间重写库方法，从而引发错误。

`ES6` 中的 `Iterability` 就是这样的一种个人方法。如果一个对象拥有一个键名是 `Symbol.iterator` 的方法，那么它就是可被遍历的。

下面的例子展示了一个可被遍历的对象：

``` javascript
	const obj = {
    	data: [ 'hello', 'world' ],
    	[Symbol.iterator]() {
        	const self = this;
      		let index = 0;
        	return {
            	next() {
                	if (index < self.data.length) {
                    return {
                        value: self.data[index++]
                    };
                	} else {
                    return { done: true };
                	}
            	}
        	};
    	}
	};
```

该对象的可遍历特性使得用户可以对它使用 `for-of` 循环或者其它相似的 JavaScript 特性：

``` javascript
	for (const x of obj) {
    	console.log(x);
	}

	// Output:
	// hello
	// world
```




### 注释
［1］： 可遍历对象是指可以被 for-of 循环或者其他语法结构遍历的对象。































